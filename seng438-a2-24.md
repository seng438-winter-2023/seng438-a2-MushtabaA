**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |     |
| -------------- | --- |
| Student Names: |     |
|                |     |
|                |     |
|                |     |

# 1 Introduction

Text…

# 2 Detailed description of unit test strategy

## Input Partitions

```
calculateRowTotal(Values2D data, int row):
```

Spec 1:
* a) Values2D data is not NULL (valid)
* b) Values2D data is NULL (not valid)

Spec 2:
* a) Values2D data is not empty (valid)
* b) Values2D data is empty (valid)

Spec 3:
* a) Row index within Values2D data range (valid)
* b) Row index negative & below Values2D data range (not valid)
* c) Row index greater than Values2D data range (not valid)

Spec 4:
* a) Values2D data contains negative values (valid)
* b) Values2D data contains positive values (valid)
* c) Values2D data contains negative & positive values (valid)

```
createNumberArray(double[] data):
```
Spec 1:
* a) double[] data is not NULL (valid)
* b) double[] data is NULL (not valid)

Spec 2:
* a) double[] data is not empty (valid)
* b) double[] data is empty (valid)

Spec 3:
* a) double[] data contains negative values (valid)
* b) double[] data contains positive values (valid)
* c) double[] data contains negative decimal values (valid)
* d) double[] data contains positive decimal values (valid)

Spec 4:
* a) double[] data contains lowest possible normal value (valid)
* b) double[] data contains maximum positive value (valid)



# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

One of the main lessons that we learned while working on the assignment was how efficient we were compared to the use of exploratory/manual functional testing in the previous assignment. With the use of JUnit and JMock, we were able to easily automate the testing procedure, saving us a bunch of time in the process. This was extremely evident when it came to the process of equivalent class testing. For instance, in the previous assignment, when it came to testing a certain partition of a particular method, the use of manual functional testing quickly became a tedious task, as we had to manually test each functionality to ensure its validity. However, JUnit sped up the process, as once we were able to partition our test cases using equivalence class testing, the automated testing process made it much easier to efficiently run our test cases, as well as create multiple test cases with ease within a partition when it came to boundary testing. Nonetheless, we did run into difficulties when it came to the setup of the environment for the use of both JUnit and JMock. Since we are using a GitHub repository, when we initially set up the java project we realized that we all had to import the external libraries in order to get JUnit and JMock to work correctly. However, once we pushed our changes, we started to run into difficulties as the libraries that each person imported were now also part of the java project, which caused errors when we tried to create/run tests using JUnit. Likewise, we overcame this difficulty by making sure that everyone removed the duplicate/unnecessary libraries from their local environment, which allowed everyone to run and create tests without errors.

# 6 Comments/feedback on the lab itself

Text…
