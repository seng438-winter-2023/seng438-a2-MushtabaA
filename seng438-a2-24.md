**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |     |
| -------------- | --- |
| Student Names: |  Ahad Ali   |
|                |  Mushtaba Al Yasseen   |
|                |  Parbir Lehal   |
|                |  Athul Rajagopal   |

# 1 Introduction

Text…


# 2 Detailed description of unit test strategy

### Input Partitions: Range Class Methods

#### `contains(double value)` ####
1.	**value** existence
	-	value does not exist (Invalid)
	-	value does exist (Valid)
2. 	**value** bound values
	- 	value is lower bound (Valid)
	- 	value is upper bound (Valid)
3. 	**value** values
	-	value is a negative number (Valid)
	-	value is a positive number (Valid)

#### `getLength(double value)` ####
1.	**range** margins
	-	range length is 0 (Valid)
	-	range length is greater than 0 (Valid)
2. 	**range** bound values
	- 	only lower bound is decimal (Valid)
	- 	only upper bound is decimal (Valid)
	- 	both bounds are decimal (Valid)
	- 	both bounds are whole number (Valid)
3. 	**range** bound signage
	- 	only upper bound is positive (Valid)
	- 	both bounds are positive (Valid)
	- 	both bounds are negative (Valid)


### Input Partitions: DataUtilites Class Methods

#### `calculateColumnTotal(Values2D data, int column)` ####
1.	A null **data** 
	-	data is null (Invalid)
	-	data is not null (Valid)
2. 	An empty **data**
	-	data can be empty (Valid)
	-	data can has one or more elements (Valid)
3. 	Positive or negative values in **data**
	- 	elements are negative numbers (Valid)
	- 	elements are positive numbers (Valid)
4. 	**column** value 
	-	column is negative index (Invalid)
	-	column is at least zero (Valid)


```
calculateRowTotal(Values2D data, int row):
```

Spec 1:
* a) Values2D data is not NULL (valid)
* b) Values2D data is NULL (not valid)

Spec 2:
* a) Values2D data is not empty (valid)
* b) Values2D data is empty (valid)

Spec 3:
* a) Row index within Values2D data range (valid)
* b) Row index negative & below Values2D data range (not valid)
* c) Row index greater than Values2D data range (not valid)

Spec 4:
* a) Values2D data contains negative values (valid)
* b) Values2D data contains positive values (valid)
* c) Values2D data contains negative & positive values (valid)

```
createNumberArray(double[] data):
```
Spec 1:
* a) double[] data is not NULL (valid)
* b) double[] data is NULL (not valid)

Spec 2:
* a) double[] data is not empty (valid)
* b) double[] data is empty (valid)

Spec 3:
* a) double[] data contains negative values (valid)
* b) double[] data contains positive values (valid)
* c) double[] data contains negative decimal values (valid)
* d) double[] data contains positive decimal values (valid)

Spec 4:
* a) double[] data contains lowest possible normal value (valid)
* b) double[] data contains maximum positive value (valid)

# 3 Test cases developed

Text…

// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

Text…

# 5 Difficulties encountered, challenges overcome, and lessons learned

One of the main lessons that we learned while working on the assignment was how efficient we were compared to the use of exploratory/manual functional testing in the previous assignment. With the use of JUnit and JMock, we were able to easily automate the testing procedure, saving us a bunch of time in the process. This was extremely evident when it came to the process of equivalent class testing. For instance, in the previous assignment, when it came to testing a certain partition of a particular method, the use of manual functional testing quickly became a tedious task, as we had to manually test each functionality to ensure its validity. However, JUnit sped up the process, as once we were able to partition our test cases using equivalence class testing, the automated testing process made it much easier to efficiently run our test cases, as well as create multiple test cases with ease within a partition when it came to boundary testing. Nonetheless, we did run into difficulties when it came to the setup of the environment for the use of both JUnit and JMock. Since we are using a GitHub repository, when we initially set up the java project we realized that we all had to import the external libraries in order to get JUnit and JMock to work correctly. However, once we pushed our changes, we started to run into difficulties as the libraries that each person imported were now also part of the java project, which caused errors when we tried to create/run tests using JUnit. Likewise, we overcame this difficulty by making sure that everyone removed the duplicate/unnecessary libraries from their local environment, which allowed everyone to run and create tests without errors.

# 6 Comments/feedback on the lab itself

Text…
